<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heatmap Testi (Proof of Concept)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <style>
        body { font-family: sans-serif; background-color: #121829; color: white; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        #status { font-size: 18px; margin-bottom: 20px; min-height: 25px; }
        #image-container { position: relative; border: 2px solid #fff; }
        #heatmap-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.6; }
        #source-image { max-width: 512px; height: auto; display: block; }
        #layer-info { margin-top: 20px; font-family: monospace; background: #333; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto; }
    </style>
</head>
<body>

    <h2 id="status">Model yükleniyor...</h2>
    
    <div id="image-container">
        <img id="source-image" crossorigin="anonymous" src="https://i.imgur.com/5tF42rg.jpg" alt="Örnek MR Görüntüsü" />
        <canvas id="heatmap-canvas"></canvas>
    </div>
    
    <div id="layer-info">Model katman bilgileri burada görünecek...</div>

    <script>
        // --- DEĞİŞKENLER ---
        const MODEL_URL = "./model/";
        const imageElement = document.getElementById('source-image');
        const statusElement = document.getElementById('status');
        const layerInfoElement = document.getElementById('layer-info');
        const canvas = document.getElementById('heatmap-canvas');
        const ctx = canvas.getContext('2d');
        
        // Bu, Teachable Machine'in kullandığı MobileNet modelindeki son evrişimli katmanın adıdır.
        // Genellikle bu katman en iyi görsel özellikleri içerir. Model farklıysa bu değişebilir.
        const TARGET_LAYER_NAME = 'conv_pw_13_relu'; 
        
        // --- ANA FONKSİYON ---
        async function runHeatmapTest() {
            try {
                // 1. Modeli Yükle
                statusElement.textContent = "Model yükleniyor...";
                const model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
                statusElement.textContent = "Model yüklendi. Katmanlar inceleniyor...";
                
                // Modelin içindeki asıl TensorFlow.js modelini al
                const underlyingModel = model.model;

                // Katman bilgilerini ekrana yazdır (hata ayıklama için)
                let layerNames = underlyingModel.layers.map(l => l.name);
                layerInfoElement.innerHTML = "<b>Model Katmanları:</b><br>" + layerNames.join('<br>');

                // 2. Hedef Katmanı Bul
                const targetLayer = underlyingModel.layers.find(layer => layer.name === TARGET_LAYER_NAME);
                if (!targetLayer) {
                    statusElement.textContent = `HATA: '${TARGET_LAYER_NAME}' katmanı bulunamadı! Lütfen listeden başka bir 'conv' katmanı deneyin.`;
                    return;
                }
                statusElement.textContent = `Hedef katman bulundu: ${targetLayer.name}`;
                
                // 3. Kısmi Model Oluştur
                // Bu yeni model, orijinal modelle aynı girdiyi alır ama çıktısı hedef katmanın çıktısı olur.
                const activationModel = tf.model({
                    inputs: underlyingModel.inputs,
                    outputs: [targetLayer.output, underlyingModel.output]
                });

                // 4. Görüntüyü Tensöre Çevir
                const imageTensor = tf.tidy(() => {
                    const tensor = tf.browser.fromPixels(imageElement).toFloat();
                    // Teachable Machine'in kullandığı normalizasyon (-1 ile 1 arası)
                    const offset = tf.scalar(127.5);
                    return tensor.sub(offset).div(offset).expandDims();
                });
                
                // 5. Grad-CAM Mantığını Uygula
                statusElement.textContent = "Heatmap hesaplanıyor...";
                let heatmapTensor;

                // Gradyanları hesaplamak için bir fonksiyon tanımla
                function getGrads() {
                    return tf.tidy(() => {
                        // Kısmi modelden hem katman aktivasyonlarını hem de son tahmini al
                        const [convOutput, predictions] = activationModel.predict(imageTensor);
                        
                        // En yüksek olasılıklı sınıfın indeksini bul
                        const topClassIndex = predictions.argMax(-1).dataSync()[0];

                        // Sadece en yüksek sınıfın tahmin skorunu al
                        const topClassScore = predictions.gather([topClassIndex], 1);

                        // Bu skorun, hedef katmanın çıktısına göre gradyanını hesapla.
                        // Bu, "hangi piksellerin bu skoru en çok etkilediğini" söyler.
                        const grads = tf.grad(p => p.sum())(topClassScore, convOutput);
                        
                        // Aktivasyonları ve gradyanları döndür
                        return { convOutput: convOutput.squeeze(), grads: grads.squeeze() };
                    });
                }

                // Gradyanları ve aktivasyonları al
                const { convOutput, grads } = getGrads();

                // Heatmap'i oluştur
                heatmapTensor = tf.tidy(() => {
                    // Gradyanların her bir kanalı için ortalama alarak "önem ağırlıklarını" bul
                    const weights = tf.mean(grads, [0, 1]);

                    // Katman çıktısını (aktivasyonları) bu ağırlıklarla çarp
                    const weightedActivations = convOutput.mul(weights);

                    // Ağırlıklandırılmış aktivasyonları toplayarak heatmap'i oluştur
                    let heatmap = tf.sum(weightedActivations, -1);
                    
                    // Görselleştirmek için normalize et (0-1 arası)
                    heatmap = heatmap.sub(tf.min(heatmap));
                    heatmap = heatmap.div(tf.max(heatmap));
                    
                    return heatmap;
                });
                
                // 6. Heatmap'i Canvas Üzerine Çiz
                await drawHeatmap(heatmapTensor);
                statusElement.textContent = "Heatmap başarıyla oluşturuldu!";

                // Hafızayı temizle
                tf.dispose([imageTensor, heatmapTensor, convOutput, grads]);

            } catch (error) {
                statusElement.textContent = "Bir hata oluştu: " + error.message;
                console.error(error);
            }
        }

        // Heatmap'i renklendirip çizen yardımcı fonksiyon
        async function drawHeatmap(heatmap) {
            const [height, width] = heatmap.shape;
            const heatmapData = await heatmap.data();
            
            // Canvas boyutlarını ayarla
            canvas.width = imageElement.width;
            canvas.height = imageElement.height;
            
            const resizedHeatmap = await tf.image.resizeBilinear(heatmap.expandDims(-1), [canvas.height, canvas.width]).data();

            // Colormap (Siyah -> Mavi -> Yeşil -> Sarı -> Kırmızı)
            const colors = [ [0, 0, 0], [0, 0, 255], [0, 255, 0], [255, 255, 0], [255, 0, 0] ];
            
            function getColor(value) {
                const scaledValue = value * (colors.length - 1);
                const i = Math.floor(scaledValue);
                const j = Math.ceil(scaledValue);
                const frac = scaledValue - i;
                
                const r = Math.round(colors[i][0] + (colors[j][0] - colors[i][0]) * frac);
                const g = Math.round(colors[i][1] + (colors[j][1] - colors[i][1]) * frac);
                const b = Math.round(colors[i][2] + (colors[j][2] - colors[i][2]) * frac);
                
                return [r, g, b];
            }

            const imageData = ctx.createImageData(canvas.width, canvas.height);
            for (let i = 0; i < resizedHeatmap.length; i++) {
                const [r, g, b] = getColor(resizedHeatmap[i]);
                imageData.data[i * 4] = r;
                imageData.data[i * 4 + 1] = g;
                imageData.data[i * 4 + 2] = b;
                imageData.data[i * 4 + 3] = 255;
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // Görüntü yüklendiğinde testi başlat
        imageElement.onload = () => {
            runHeatmapTest();
        };
        // Görüntü zaten cache'de ise
        if (imageElement.complete) {
            imageElement.onload();
        }

    </script>
</body>
</html>